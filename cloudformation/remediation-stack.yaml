AWSTemplateFormatVersion: '2010-09-09'
Description: Detect and remediate world-open SSH/RDP using AWS Config + SSM Automation + Lambda.

Parameters:
  FunctionName:
    Type: String
    Default: ConfigSGRevokerLambda
    Description: Name for the remediation Lambda.

Resources:
  # 1) Lambda execution role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: [ lambda.amazonaws.com ] }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaEc2Revoke
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:RevokeSecurityGroupIngress
                Resource: '*'

  # 2) Remediation Lambda (inline code)
  RemediationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref FunctionName
      Runtime: python3.11
      Handler: index.lambda_handler
      Timeout: 60
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3, json
          from botocore.exceptions import ClientError
          ec2 = boto3.client('ec2')

          def lambda_handler(event, context):
              print(f"Received event: {json.dumps(event)}")
              sg_id = None
              if isinstance(event, dict):
                  sg_id = event.get('resourceId') or event.get('detail', {}).get('resourceId')
              if not sg_id:
                  return {"statusCode": 400, "body": "Missing Security Group ID"}

              try:
                  resp = ec2.describe_security_groups(GroupIds=[sg_id])
                  sg = resp["SecurityGroups"][0]
              except ClientError as e:
                  print(f"DescribeSecurityGroups failed for {sg_id}: {e}")
                  raise

              perms = []
              for p in sg.get("IpPermissions", []):
                  proto = p.get("IpProtocol")
                  fp, tp = p.get("FromPort"), p.get("ToPort")
                  is_ssh = (fp == 22 and tp == 22)
                  is_rdp = (fp == 3389 and tp == 3389)
                  all_traffic = (proto == "-1")
                  if not (is_ssh or is_rdp or all_traffic):
                      continue

                  for r in p.get("IpRanges", []):
                      if r.get("CidrIp") == "0.0.0.0/0":
                          if all_traffic:
                              perms.extend([
                                  {"IpProtocol":"tcp","FromPort":22,"ToPort":22,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]},
                                  {"IpProtocol":"tcp","FromPort":3389,"ToPort":3389,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]},
                              ])
                          else:
                              perms.append({"IpProtocol":proto,"FromPort":fp,"ToPort":tp,"IpRanges":[{"CidrIp":"0.0.0.0/0"}]})

                  for r6 in p.get("Ipv6Ranges", []):
                      if r6.get("CidrIpv6") == "::/0":
                          if all_traffic:
                              perms.extend([
                                  {"IpProtocol":"tcp","FromPort":22,"ToPort":22,"Ipv6Ranges":[{"CidrIpv6":"::/0"}]},
                                  {"IpProtocol":"tcp","FromPort":3389,"ToPort":3389,"Ipv6Ranges":[{"CidrIpv6":"::/0"}]},
                              ])
                          else:
                              perms.append({"IpProtocol":proto,"FromPort":fp,"ToPort":tp,"Ipv6Ranges":[{"CidrIpv6":"::/0"}]})

              if not perms:
                  print("No non-compliant rules found")
                  return {"statusCode":200,"body":"Compliant"}

              def key(p):
                  return (
                      p["IpProtocol"], p.get("FromPort"), p.get("ToPort"),
                      tuple(sorted([r.get("CidrIp") for r in p.get("IpRanges", []) if "CidrIp" in r])),
                      tuple(sorted([r.get("CidrIpv6") for r in p.get("Ipv6Ranges", []) if "CidrIpv6" in r])),
                  )
              perms = list({key(p):p for p in perms}.values())

              try:
                  ec2.revoke_security_group_ingress(GroupId=sg_id, IpPermissions=perms)
                  print(f"Revoked {len(perms)} rule(s) on {sg_id}")
                  return {"statusCode":200,"body":"Remediation successful"}
              except ClientError as e:
                  if e.response["Error"]["Code"] == "InvalidPermission.NotFound":
                      print(f"Rules already removed for {sg_id}")
                      return {"statusCode":200,"body":"Already remediated"}
                  print(f"Revoke failed for {sg_id}: {e}")
                  raise

  # 3) SSM Automation role (assumed by SSM)
  AutomationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: RMF-Auto-SG-AutomationRole
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: [ ssm.amazonaws.com ] }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RemediateOpenSgPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:RevokeSecurityGroupIngress
                Resource: '*'
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt RemediationLambda.Arn

  # 4) SSM Automation Document that calls the Lambda
  RemediateOpenSgDoc:
    Type: AWS::SSM::Document
    Properties:
      DocumentType: Automation
      Content:
        description: "Automation to remediate world-open SSH/RDP SG rules"
        schemaVersion: '0.3'
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          SecurityGroupId: { type: String }
          AutomationAssumeRole: { type: String }
          LambdaFnName: { type: String }
        mainSteps:
          - name: InvokeLambda
            action: aws:invokeLambdaFunction
            inputs:
              FunctionName: "{{ LambdaFnName }}"
              Payload: |
                { "resourceId": "{{ SecurityGroupId }}" }

  # 5) Config rules (AWS managed: RESTRICTED_INCOMING_TRAFFIC)
  ConfigRuleSsh:
    Type: AWS::Config::ConfigRule
    Properties:
      ConfigRuleName: Incoming-SSH-Disabled
      Description: Flags SGs that allow SSH (22) from 0.0.0.0/0 or ::/0.
      Source:
        Owner: AWS
        SourceIdentifier: RESTRICTED_INCOMING_TRAFFIC
      Scope:
        ComplianceResourceTypes: [ AWS::EC2::SecurityGroup ]
      InputParameters:
        blockedPorts: '22'

  ConfigRuleRdp:
    Type: AWS::Config::ConfigRule
    Properties:
      ConfigRuleName: Incoming-RDP-Disabled
      Description: Flags SGs that allow RDP (3389) from 0.0.0.0/0 or ::/0.
      Source:
        Owner: AWS
        SourceIdentifier: RESTRICTED_INCOMING_TRAFFIC
      Scope:
        ComplianceResourceTypes: [ AWS::EC2::SecurityGroup ]
      InputParameters:
        blockedPorts: '3389'

  # 6) Remediation configs pointing to the same SSM document
  VpcSgRemediationConfigSsh:
    Type: AWS::Config::RemediationConfiguration
    Properties:
      ConfigRuleName: !Ref ConfigRuleSsh
      TargetType: SSM_DOCUMENT
      TargetId: !Ref RemediateOpenSgDoc
      TargetVersion: "1"
      Automatic: true
      MaximumAutomaticAttempts: 1
      RetryAttemptSeconds: 60
      Parameters:
        AutomationAssumeRole:
          StaticValue:
            Values: [ !GetAtt AutomationRole.Arn ]
        SecurityGroupId:
          ResourceValue:
            Value: RESOURCE_ID
        LambdaFnName:
          StaticValue:
            Values: [ !Ref FunctionName ]

  VpcSgRemediationConfigRdp:
    Type: AWS::Config::RemediationConfiguration
    Properties:
      ConfigRuleName: !Ref ConfigRuleRdp
      TargetType: SSM_DOCUMENT
      TargetId: !Ref RemediateOpenSgDoc
      TargetVersion: "1"
      Automatic: true
      MaximumAutomaticAttempts: 1
      RetryAttemptSeconds: 60
      Parameters:
        AutomationAssumeRole:
          StaticValue:
            Values: [ !GetAtt AutomationRole.Arn ]
        SecurityGroupId:
          ResourceValue:
            Value: RESOURCE_ID
        LambdaFnName:
          StaticValue:
            Values: [ !Ref FunctionName ]
